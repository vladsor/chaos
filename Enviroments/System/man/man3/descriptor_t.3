.TH "descriptor_t" 3 "29 Jul 2004" "Systemenviroment" \" -*- nroff -*-
.ad l
.nh
.SH NAME
descriptor_t \- A descriptor.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <descriptor.h>\fP
.PP
.SS "Data Fields"

.in +1c
.ti -1c
.RI "\fBuint16_t\fP \fBlimit_lo\fP"
.br
.RI "\fILow 16 bits of segment limit. \fP"
.ti -1c
.RI "\fBuint16_t\fP \fBbase_lo\fP"
.br
.RI "\fILow 16 bits of base address. \fP"
.ti -1c
.RI "\fBuint8_t\fP \fBbase_hi\fP"
.br
.RI "\fIBits 16-23 of base address. \fP"
.ti -1c
.RI "\fBuint8_t\fP \fBtype\fP: 4"
.br
.RI "\fISegment type. \fP"
.ti -1c
.RI "\fBuint8_t\fP \fBdescriptor_type\fP: 1"
.br
.RI "\fIS (descriptor type) flag. \fP"
.ti -1c
.RI "\fBuint8_t\fP \fBdpl\fP: 2"
.br
.RI "\fIDPL (descriptor privilege level) field. \fP"
.ti -1c
.RI "\fBuint8_t\fP \fBsegment_present\fP: 1"
.br
.RI "\fIP (segment-present) flag. \fP"
.ti -1c
.RI "\fBuint8_t\fP \fBlimit_hi\fP: 4"
.br
.RI "\fIHigh four bits of segment limit. \fP"
.ti -1c
.RI "\fBuint8_t\fP \fBavailable\fP: 1"
.br
.RI "\fIAvailable for system programmer's use. \fP"
.ti -1c
.RI "\fBuint8_t\fP \fBzero\fP: 1"
.br
.RI "\fIReserved (set to 0). \fP"
.ti -1c
.RI "\fBuint8_t\fP \fBdefault_operation_size\fP: 1"
.br
.RI "\fID/B (default operation size/default stack pointer size and/or upper bound) flag. \fP"
.ti -1c
.RI "\fBuint8_t\fP \fBgranularity\fP: 1"
.br
.RI "\fIG (granularity) flag. \fP"
.ti -1c
.RI "\fBuint8_t\fP \fBbase_hi2\fP"
.br
.RI "\fIBits 24-31 of base address. \fP"
.in -1c
.SH "Detailed Description"
.PP 
A descriptor. 
.SH "Field Documentation"
.PP 
.SS "\fBuint8_t\fP \fBdescriptor_t::type\fP"
.PP
Segment type. Type field Indicates the segment or gate type and specifies the kinds of access that can be made to the segment and the direction of growth. The interpretation of this field depends on whether the descriptor type flag specifies an application (code or data) descriptor or a system descriptor. The encoding of the type field is different for code, data, and system descriptors (refer to Figure 4-1 in Chapter 4, Protection). Refer to Section 3.4.3.1., “Code- and Data-Segment Descriptor Types” for a description of how this field is used to specify code and datasegment types. 
.SS "\fBuint8_t\fP \fBdescriptor_t::descriptor_type\fP"
.PP
S (descriptor type) flag. Specifies whether the segment descriptor is for a system segment (S flag is clear) or a code or data segment (S flag is set). 
.SS "\fBuint8_t\fP \fBdescriptor_t::dpl\fP"
.PP
DPL (descriptor privilege level) field. Specifies the privilege level of the segment. The privilege level can range from 0 to 3, with 0 being the most privileged level. The DPL is used to control access to the segment. Refer to Section 4.5., “Privilege Levels” in Chapter 4, Protection for a description of the relationship of the DPL to the CPL of the executing code segment and the RPL of a segment selector. 
.SS "\fBuint8_t\fP \fBdescriptor_t::segment_present\fP"
.PP
P (segment-present) flag. Indicates whether the segment is present in memory (set) or not present (clear). If this flag is clear, the processor generates a segment-not-present exception (#NP) when a segment selector that points to the segment descriptor is loaded into a segment register. Memory management software can use this flag to control which segments are actually loaded into physical memory at a given time. It offers a control in addition to paging for managing virtual memory.
.br
 When this flag is clear, the operating system or executive is free to use the locations marked “Available” to store its own data, such as information regarding the whereabouts of the missing segment. 
.SS "\fBuint8_t\fP \fBdescriptor_t::default_operation_size\fP"
.PP
D/B (default operation size/default stack pointer size and/or upper bound) flag. Performs different functions depending on whether the segment descriptor is an executable code segment, an expand-down data segment, or a stack segment. (This flag should always be set to 1 for 32-bit code and data segments and to 0 for 16-bit code and data segments.) .PD 0

.IP "\(bu" 2
Executable code segment. The flag is called the D flag and it indicates the default length for effective addresses and operands referenced by instructions in the segment. If the flag is set, 32-bit addresses and 32-bit or 8-bit operands are assumed; if it is clear, 16-bit addresses and 16-bit or 8-bit operands are assumed. The instruction prefix 66H can be used to select an operand size other than the default, and the prefix 67H can be used select an address size other than the default.  
.IP "\(bu" 2
Stack segment (data segment pointed to by the SS register). The flag is called the B (big) flag and it specifies the size of the stack pointer used for implicit stack operations (such as pushes, pops, and calls). If the flag is set, a 32-bit stack pointer is used, which is stored in the 32-bit ESP register; if the flag is clear, a 16-bit stack pointer is used, which is stored in the 16-bit SP register. If the stack segment is set up to be an expand-down data segment (described in the next paragraph), the B flag also specifies the upper bound of the stack segment.  
.IP "\(bu" 2
Expand-down data segment. The flag is called the B flag and it specifies the upper bound of the segment. If the flag is set, the upper bound is FFFFFFFFH (4 GBytes); if the flag is clear, the upper bound is FFFFH (64 KBytes).  
.PP

.SS "\fBuint8_t\fP \fBdescriptor_t::granularity\fP"
.PP
G (granularity) flag. Determines the scaling of the segment limit field. When the granularity flag is clear, the segment limit is interpreted in byte units; when flag is set, the segment limit is interpreted in 4-KByte units. (This flag does not affect the granularity of the base address; it is always byte granular.) When the granularity flag is set, the twelve least significant bits of an offset are not tested when checking the offset against the segment limit. For example, when the granularity flag is set, a limit of 0 results in valid offsets from 0 to 4095. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Systemenviroment from the source code.
