/* $chaos: vgamode.c,v 1.2 2002/10/04 19:01:07 per Exp $ */
/* Abstract: Mode setting code. */
/* Author: Per Lundberg <per@chaosdev.org>
           Vladimir Sorokin */

/* Copyright 2002 chaos development. */
/* Use freely under the terms listed in the file LICENSE. */

/* Much of this code was taken from vgadrv.c in svgalib -- thanks to
   you guys! */

#include <enviroment.h>
#include "vgaio.h"

/* BIOS mode 03h - 80x25 text */
static const char t80x25_regs[60] =
{
    0x5B, 0x4F, 0x53, 0x37, 0x51, 0x5B, 0x6C, 0x1F, 0x00, 0x0D, 0x0a, 0x0c,
    0x00, 0x00, 0x00, 0x00, 0x5E, 0x2B, 0x5D, 0x28, 0x0F, 0x5E, 0x0A, 0xA3,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B,
    0x3C, 0x3D, 0x3E, 0x3F, 0x0A, 0x00, 0x0F, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF,
    0x03, 0x01, 0x03, 0x00, 0x03,
    0xA7
};

static const char t80x50_regs[60] =
{
    0x5B, 0x4F, 0x53, 0x37, 0x51, 0x5B, 0x6C, 0x1F, 0x00, 0x0D, 0x0a, 0x0c,
    0x00, 0x00, 0x00, 0x00, 0x5E, 0x2B, 0x5D, 0x28, 0x0F, 0x5E, 0x0A, 0xA3,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B,
    0x3C, 0x3D, 0x3E, 0x3F, 0x0A, 0x00, 0x0F, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF,
    0x03, 0x01, 0x03, 0x00, 0x03,
    0xA7
};

/* BIOS mode 0Dh - 320x200x16 */
static const unsigned char g320x200x16_regs[60] =
{
    0x2D, 0x27, 0x28, 0x90, 0x2B, 0x80, 0xBF, 0x1F, 0x00, 0xC0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x14, 0x00, 0x96, 0xB9, 0xE3,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
    0x0C, 0x0D, 0x0E, 0x0F, 0x01, 0x00, 0x0F, 0x00, 0x00,
    0x00, 0x0F, 0x00, 0x20, 0x00, 0x00, 0x05, 0x0F, 0xFF,
    0x03, 0x09, 0x0F, 0x00, 0x06,
    0x63
};

/* BIOS mode 0Eh - 640x200x16 */
static const unsigned char g640x200x16_regs[60] =
{
    0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F, 0x00, 0xC0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x00, 0x96, 0xB9, 0xE3,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
    0x0C, 0x0D, 0x0E, 0x0F, 0x01, 0x00, 0x0F, 0x00, 0x00,
    0x00, 0x0F, 0x00, 0x20, 0x00, 0x00, 0x05, 0x0F, 0xFF,
    0x03, 0x01, 0x0F, 0x00, 0x06,
    0x63
};

/* BIOS mode 10h - 640x350x16 */
static const unsigned char g640x350x16_regs[60] =
{
    0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F, 0x00, 0x40, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x83, 0x85, 0x5D, 0x28, 0x0F, 0x63, 0xBA, 0xE3,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
    0x0C, 0x0D, 0x0E, 0x0F, 0x01, 0x00, 0x0F, 0x00, 0x00,
    0x00, 0x0F, 0x00, 0x20, 0x00, 0x00, 0x05, 0x0F, 0xFF,
    0x03, 0x01, 0x0F, 0x00, 0x06,
    0xA3
};

/* BIOS mode 12h - 640x480x16 */
static const unsigned char g640x480x16_regs[60] =
{
    0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xEA, 0x8C, 0xDF, 0x28, 0x00, 0xE7, 0x04, 0xE3,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
    0x0C, 0x0D, 0x0E, 0x0F, 0x01, 0x00, 0x0F, 0x00, 0x00,
    0x00, 0x0F, 0x00, 0x20, 0x00, 0x00, 0x05, 0x0F, 0xFF,
    0x03, 0x01, 0x0F, 0x00, 0x06,
    0xE3
};

/* BIOS mode 13h - 320x200x256 */
static const unsigned char g320x200x256_regs[60] =
{
    0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F, 0x00, 0x41, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x40, 0x96, 0xB9, 0xA3,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
    0x0C, 0x0D, 0x0E, 0x0F, 0x41, 0x00, 0x0F, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF,
    0x03, 0x01, 0x0F, 0x00, 0x0E,
    0x63
};

/* non-BIOS mode - 320x240x256 */
static const unsigned char g320x240x256_regs[60] =
{
    0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0x0D, 0x3E, 0x00, 0x41, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xEA, 0xAC, 0xDF, 0x28, 0x00, 0xE7, 0x06, 0xE3,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
    0x0C, 0x0D, 0x0E, 0x0F, 0x41, 0x00, 0x0F, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF,
    0x03, 0x01, 0x0F, 0x00, 0x06,
    0xE3
};

/* non-BIOS mode - 320x400x256 */
static const unsigned char g320x400x256_regs[60] =
{
    0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F, 0x00, 0x40, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x00, 0x96, 0xB9, 0xE3,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
    0x0C, 0x0D, 0x0E, 0x0F, 0x41, 0x00, 0x0F, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF,
    0x03, 0x01, 0x0F, 0x00, 0x06,
    0x63
};

/* non-BIOS mode - 360x480x256 */
static const unsigned char g360x480x256_regs[60] =
{
    0x6B, 0x59, 0x5A, 0x8E, 0x5E, 0x8A, 0x0D, 0x3E, 0x00, 0x40, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xEA, 0xAC, 0xDF, 0x2D, 0x00, 0xE7, 0x06, 0xE3,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
    0x0C, 0x0D, 0x0E, 0x0F, 0x41, 0x00, 0x0F, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF,
    0x03, 0x01, 0x0F, 0x00, 0x06,
    0xE7
};

/* monochrome mode based on BIOS mode 12h - 640x480x2 */
#define g640x480x2_regs g640x480x16_regs

/* non BIOS mode - 720x348x2 based on mode 10h */
static const unsigned char g720x348x2_regs[60] =
{
    0x6B, 0x59, 0x5A, 0x8E, 0x5E, 0x8A, 0xBF, 0x1F, 0x00, 0x40, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x83, 0x85, 0x5D, 0x2D, 0x0F, 0x63, 0xBA, 0xE3,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
    0x0C, 0x0D, 0x0E, 0x0F, 0x01, 0x00, 0x0F, 0x00, 0x00,
    0x00, 0x0F, 0x00, 0x20, 0x00, 0x00, 0x05, 0x0F, 0xFF,
    0x03, 0x01, 0x0F, 0x00, 0x06,
    0xA7
};

#define EGA 0
#define VGA 1

int vga_chipset = VGA;

void vga_set_mode (int mode)
{
//  debug_print ("VGA set mode.\n");

  vga_io_init ();
  setregs (g360x480x256_regs);
//  t80x25_regs);
//  debug_print ("Test in new mode.");
}

int setregs (const unsigned char *regs)
{
    int i;

//    debug_print ("VGA seting registers.\n");

    if (vga_chipset == EGA) 
    {
        /* Enable graphics register modification */
        port_uint16_out (GRA_E0, 0x00);
        port_uint16_out (GRA_E1, 0x01);
    }
    /* update misc output register */
    vga_misc_out (regs[MIS]);

    /* synchronous reset on */
    vga_seq_out (0x00, 0x01);

    /* write sequencer registers */
    vga_seq_out (0x01, regs[SEQ + 1] | 0x20);
    port_uint16_out (SEQ_I, 1);
    port_uint16_out (SEQ_D, regs[SEQ + 1] | 0x20);
    
    for (i = 2; i < SEQ_C; i++) 
    {
       vga_seq_out (regs[SEQ + i], i);
    }

    /* synchronous reset off */
    vga_seq_out (0x00, 0x03);

    if (vga_chipset != EGA) 
    {
        /* deprotect CRT registers 0-7 */
        vga_crtc_out (0x11, vga_crtc_in (0x11) & 0x7F);
    }
    
    /* write CRT registers */
    for (i = 0; i < CRT_C; i++) 
    {
        vga_crtc_out (regs[CRT + i], i);
    }

    /* write graphics controller registers */
    for (i = 0; i < GRA_C; i++) 
    {
        port_uint16_out (GRA_I, i);
        port_uint16_out (GRA_D, regs[GRA + i]);
    }

    /* write attribute controller registers */
    for (i = 0; i < ATT_C; i++) 
    {
        port_uint16_in (vga_IS1_R);      /* reset flip-flop */
        vga_delay ();
        port_uint16_out (ATT_IW, i);
        vga_delay ();
        port_uint16_out (ATT_IW, regs[ATT + i]);
        vga_delay ();
    }

    return 0;
}

#if 0
static void restore_text(void)
{

          __svgalib_outseq(0x02,0x01);
          
	  slowcpy(GM, text_buf1, TEXT_SIZE);

          __svgalib_outseq(0x02,0x02);

	  slowcpy(GM, text_buf2, TEXT_SIZE);

   	  if(__svgalib_savemem)
              memcpy(LINEAR_POINTER,vmem_buf,__svgalib_savemem);
};

static void save_text(void)
{

   	text_buf1 = malloc(TEXT_SIZE * 2);
        text_buf2 = text_buf1 + TEXT_SIZE;

        __svgalib_outgra(0x04,0x00);

        slowcpy(text_buf1, GM, TEXT_SIZE);

        /* save font data in plane 3 */
        __svgalib_outgra(0x04,0x01);

        slowcpy(text_buf2, GM, TEXT_SIZE);

  	if(__svgalib_savemem) {
            vmem_buf=malloc(__svgalib_savemem);
            memcpy(vmem_buf,LINEAR_POINTER,__svgalib_savemem);
        }
};

    if (mode == TEXT) {
	/* Returning to textmode. */

	if (SVGAMODE(prv_mode))
	    vga_setpage(0);

	/* The extended registers are restored either by the */
	/* chipset setregs function, or the chipset setmode function. */

	/* restore font data - first select a 16 color graphics mode */
	/* Note: this should restore the old extended registers if */
	/* setregs is not defined for the chipset. */

        if (__svgalib_driverspecs->emul && __svgalib_driverspecs->emul->restorefont) {
           __svgalib_driverspecs->emul->restorefont(); 
	   chipset_setregs(text_regs, mode);
        } else if(!__svgalib_novga) {
	  __svgalib_driverspecs->setmode(GPLANE16, prv_mode);

	  if (CHIPSET != EGA)
	      /* restore old extended regs */
	      chipset_setregs(text_regs, mode);

	  /* disable Set/Reset Register */
          __svgalib_outgra(0x01,0x00);

          restore_text();

	  /* restore font data in plane 2 - necessary for all VGA's */
          __svgalib_outseq(0x02,0x04);

	  slowcpy(GM, font_buf1, FONT_SIZE);

	  /* restore font data in plane 3 - necessary for Trident VGA's */
          __svgalib_outseq(0x02,0x08);
	  slowcpy(GM, font_buf2, FONT_SIZE);

	  /* change register adresses if monochrome text mode */
	  /* EGA is assumed to use color emulation. */
	  if (!color_text) {
	      __svgalib_CRT_I = CRT_IM;
	      __svgalib_CRT_D = CRT_DM;
	      __svgalib_IS1_R = IS1_RM;
              __svgalib_vgacolormode=0;
              __svgalib_outmisc(__svgalib_inmisc() & 0xfe);
	  }
        } else chipset_setregs(text_regs, mode);

	/* restore text mode VGA registers */
	__svgalib_setregs(text_regs);

	/* restore saved palette */
	restorepalette(text_red, text_green, text_blue);

	/* Set VMEM to some minimum value .. probably pointless.. */
	{
	    vga_claimvideomemory(12);
	}

	/* enable video */
	vga_screenon();

}

int vga_screenon(void)
{
    int tmp = 0;

    SCREENON = 1;
    if(__svgalib_novga) return 0; 
    if (__svgalib_driverspecs->emul && __svgalib_driverspecs->emul->screenon) {
	tmp = __svgalib_driverspecs->emul->screenon();
    } else {
	/* turn screen back on */
	if (CHIPSET != EGA) {
            __svgalib_outseq(0x01,__svgalib_inseq(0x01) & 0xdf);
	}
/* #ifdef DISABLE_VIDEO_OUTPUT */
	/* enable video output */
	__svgalib_attscreen(0x20);
/* #endif */
    }

    return 0;
}
#endif
